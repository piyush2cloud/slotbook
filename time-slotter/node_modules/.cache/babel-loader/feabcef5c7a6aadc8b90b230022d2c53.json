{"ast":null,"code":"// Ignore warning about 'new String()'\n\n/* eslint no-new-wrappers: 0 */\n'use strict';\n\nvar os = require('os');\n\nvar fs = require('fs');\n\nvar glob = require('glob');\n\nvar shell = require('..');\n\nvar shellMethods = Object.create(shell);\nexports.extend = Object.assign; // Check if we're running under electron\n\nvar isElectron = Boolean(process.versions.electron); // Module globals (assume no execPath by default)\n\nvar DEFAULT_CONFIG = {\n  fatal: false,\n  globOptions: {},\n  maxdepth: 255,\n  noglob: false,\n  silent: false,\n  verbose: false,\n  execPath: null,\n  bufLength: 64 * 1024 // 64KB\n\n};\nvar config = {\n  reset: function () {\n    Object.assign(this, DEFAULT_CONFIG);\n\n    if (!isElectron) {\n      this.execPath = process.execPath;\n    }\n  },\n  resetForTesting: function () {\n    this.reset();\n    this.silent = true;\n  }\n};\nconfig.reset();\nexports.config = config; // Note: commands should generally consider these as read-only values.\n\nvar state = {\n  error: null,\n  errorCode: 0,\n  currentCmd: 'shell.js'\n};\nexports.state = state;\ndelete process.env.OLDPWD; // initially, there's no previous directory\n// Reliably test if something is any sort of javascript object\n\nfunction isObject(a) {\n  return typeof a === 'object' && a !== null;\n}\n\nexports.isObject = isObject;\n\nfunction log() {\n  /* istanbul ignore next */\n  if (!config.silent) {\n    console.error.apply(console, arguments);\n  }\n}\n\nexports.log = log; // Converts strings to be equivalent across all platforms. Primarily responsible\n// for making sure we use '/' instead of '\\' as path separators, but this may be\n// expanded in the future if necessary\n\nfunction convertErrorOutput(msg) {\n  if (typeof msg !== 'string') {\n    throw new TypeError('input must be a string');\n  }\n\n  return msg.replace(/\\\\/g, '/');\n}\n\nexports.convertErrorOutput = convertErrorOutput; // Shows error message. Throws if config.fatal is true\n\nfunction error(msg, _code, options) {\n  // Validate input\n  if (typeof msg !== 'string') throw new Error('msg must be a string');\n  var DEFAULT_OPTIONS = {\n    continue: false,\n    code: 1,\n    prefix: state.currentCmd + ': ',\n    silent: false\n  };\n\n  if (typeof _code === 'number' && isObject(options)) {\n    options.code = _code;\n  } else if (isObject(_code)) {\n    // no 'code'\n    options = _code;\n  } else if (typeof _code === 'number') {\n    // no 'options'\n    options = {\n      code: _code\n    };\n  } else if (typeof _code !== 'number') {\n    // only 'msg'\n    options = {};\n  }\n\n  options = Object.assign({}, DEFAULT_OPTIONS, options);\n  if (!state.errorCode) state.errorCode = options.code;\n  var logEntry = convertErrorOutput(options.prefix + msg);\n  state.error = state.error ? state.error + '\\n' : '';\n  state.error += logEntry; // Throw an error, or log the entry\n\n  if (config.fatal) throw new Error(logEntry);\n  if (msg.length > 0 && !options.silent) log(logEntry);\n\n  if (!options.continue) {\n    throw {\n      msg: 'earlyExit',\n      retValue: new ShellString('', state.error, state.errorCode)\n    };\n  }\n}\n\nexports.error = error; //@\n//@ ### ShellString(str)\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ var foo = ShellString('hello world');\n//@ ```\n//@\n//@ Turns a regular string into a string-like object similar to what each\n//@ command returns. This has special methods, like `.to()` and `.toEnd()`.\n\nfunction ShellString(stdout, stderr, code) {\n  var that;\n\n  if (stdout instanceof Array) {\n    that = stdout;\n    that.stdout = stdout.join('\\n');\n    if (stdout.length > 0) that.stdout += '\\n';\n  } else {\n    that = new String(stdout);\n    that.stdout = stdout;\n  }\n\n  that.stderr = stderr;\n  that.code = code; // A list of all commands that can appear on the right-hand side of a pipe\n  // (populated by calls to common.wrap())\n\n  pipeMethods.forEach(function (cmd) {\n    that[cmd] = shellMethods[cmd].bind(that);\n  });\n  return that;\n}\n\nexports.ShellString = ShellString; // Returns {'alice': true, 'bob': false} when passed a string and dictionary as follows:\n//   parseOptions('-a', {'a':'alice', 'b':'bob'});\n// Returns {'reference': 'string-value', 'bob': false} when passed two dictionaries of the form:\n//   parseOptions({'-r': 'string-value'}, {'r':'reference', 'b':'bob'});\n// Throws an error when passed a string that does not start with '-':\n//   parseOptions('a', {'a':'alice'}); // throws\n\nfunction parseOptions(opt, map, errorOptions) {\n  // Validate input\n  if (typeof opt !== 'string' && !isObject(opt)) {\n    throw new Error('options must be strings or key-value pairs');\n  } else if (!isObject(map)) {\n    throw new Error('parseOptions() internal error: map must be an object');\n  } else if (errorOptions && !isObject(errorOptions)) {\n    throw new Error('parseOptions() internal error: errorOptions must be object');\n  }\n\n  if (opt === '--') {\n    // This means there are no options.\n    return {};\n  } // All options are false by default\n\n\n  var options = {};\n  Object.keys(map).forEach(function (letter) {\n    var optName = map[letter];\n\n    if (optName[0] !== '!') {\n      options[optName] = false;\n    }\n  });\n  if (opt === '') return options; // defaults\n\n  if (typeof opt === 'string') {\n    if (opt[0] !== '-') {\n      throw new Error(\"Options string must start with a '-'\");\n    } // e.g. chars = ['R', 'f']\n\n\n    var chars = opt.slice(1).split('');\n    chars.forEach(function (c) {\n      if (c in map) {\n        var optionName = map[c];\n\n        if (optionName[0] === '!') {\n          options[optionName.slice(1)] = false;\n        } else {\n          options[optionName] = true;\n        }\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  } else {\n    // opt is an Object\n    Object.keys(opt).forEach(function (key) {\n      // key is a string of the form '-r', '-d', etc.\n      var c = key[1];\n\n      if (c in map) {\n        var optionName = map[c];\n        options[optionName] = opt[key]; // assign the given value\n      } else {\n        error('option not recognized: ' + c, errorOptions || {});\n      }\n    });\n  }\n\n  return options;\n}\n\nexports.parseOptions = parseOptions; // Expands wildcards with matching (ie. existing) file names.\n// For example:\n//   expand(['file*.js']) = ['file1.js', 'file2.js', ...]\n//   (if the files 'file1.js', 'file2.js', etc, exist in the current dir)\n\nfunction expand(list) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('must be an array');\n  }\n\n  var expanded = [];\n  list.forEach(function (listEl) {\n    // Don't expand non-strings\n    if (typeof listEl !== 'string') {\n      expanded.push(listEl);\n    } else {\n      var ret;\n\n      try {\n        ret = glob.sync(listEl, config.globOptions); // if nothing matched, interpret the string literally\n\n        ret = ret.length > 0 ? ret : [listEl];\n      } catch (e) {\n        // if glob fails, interpret the string literally\n        ret = [listEl];\n      }\n\n      expanded = expanded.concat(ret);\n    }\n  });\n  return expanded;\n}\n\nexports.expand = expand; // Normalizes Buffer creation, using Buffer.alloc if possible.\n// Also provides a good default buffer length for most use cases.\n\nvar buffer = typeof Buffer.alloc === 'function' ? function (len) {\n  return Buffer.alloc(len || config.bufLength);\n} : function (len) {\n  return new Buffer(len || config.bufLength);\n};\nexports.buffer = buffer; // Normalizes _unlinkSync() across platforms to match Unix behavior, i.e.\n// file can be unlinked even if it's read-only, see https://github.com/joyent/node/issues/3006\n\nfunction unlinkSync(file) {\n  try {\n    fs.unlinkSync(file);\n  } catch (e) {\n    // Try to override file permission\n\n    /* istanbul ignore next */\n    if (e.code === 'EPERM') {\n      fs.chmodSync(file, '0666');\n      fs.unlinkSync(file);\n    } else {\n      throw e;\n    }\n  }\n}\n\nexports.unlinkSync = unlinkSync; // wrappers around common.statFollowLinks and common.statNoFollowLinks that clarify intent\n// and improve readability\n\nfunction statFollowLinks() {\n  return fs.statSync.apply(fs, arguments);\n}\n\nexports.statFollowLinks = statFollowLinks;\n\nfunction statNoFollowLinks() {\n  return fs.lstatSync.apply(fs, arguments);\n}\n\nexports.statNoFollowLinks = statNoFollowLinks; // e.g. 'shelljs_a5f185d0443ca...'\n\nfunction randomFileName() {\n  function randomHash(count) {\n    if (count === 1) {\n      return parseInt(16 * Math.random(), 10).toString(16);\n    }\n\n    var hash = '';\n\n    for (var i = 0; i < count; i++) {\n      hash += randomHash(1);\n    }\n\n    return hash;\n  }\n\n  return 'shelljs_' + randomHash(20);\n}\n\nexports.randomFileName = randomFileName; // Common wrapper for all Unix-like commands that performs glob expansion,\n// command-logging, and other nice things\n\nfunction wrap(cmd, fn, options) {\n  options = options || {};\n  return function () {\n    var retValue = null;\n    state.currentCmd = cmd;\n    state.error = null;\n    state.errorCode = 0;\n\n    try {\n      var args = [].slice.call(arguments, 0); // Log the command to stderr, if appropriate\n\n      if (config.verbose) {\n        console.error.apply(console, [cmd].concat(args));\n      } // If this is coming from a pipe, let's set the pipedValue (otherwise, set\n      // it to the empty string)\n\n\n      state.pipedValue = this && typeof this.stdout === 'string' ? this.stdout : '';\n\n      if (options.unix === false) {\n        // this branch is for exec()\n        retValue = fn.apply(this, args);\n      } else {\n        // and this branch is for everything else\n        if (isObject(args[0]) && args[0].constructor.name === 'Object') {// a no-op, allowing the syntax `touch({'-r': file}, ...)`\n        } else if (args.length === 0 || typeof args[0] !== 'string' || args[0].length <= 1 || args[0][0] !== '-') {\n          args.unshift(''); // only add dummy option if '-option' not already present\n        } // flatten out arrays that are arguments, to make the syntax:\n        //    `cp([file1, file2, file3], dest);`\n        // equivalent to:\n        //    `cp(file1, file2, file3, dest);`\n\n\n        args = args.reduce(function (accum, cur) {\n          if (Array.isArray(cur)) {\n            return accum.concat(cur);\n          }\n\n          accum.push(cur);\n          return accum;\n        }, []); // Convert ShellStrings (basically just String objects) to regular strings\n\n        args = args.map(function (arg) {\n          if (isObject(arg) && arg.constructor.name === 'String') {\n            return arg.toString();\n          }\n\n          return arg;\n        }); // Expand the '~' if appropriate\n\n        var homeDir = os.homedir();\n        args = args.map(function (arg) {\n          if (typeof arg === 'string' && arg.slice(0, 2) === '~/' || arg === '~') {\n            return arg.replace(/^~/, homeDir);\n          }\n\n          return arg;\n        }); // Perform glob-expansion on all arguments after globStart, but preserve\n        // the arguments before it (like regexes for sed and grep)\n\n        if (!config.noglob && options.allowGlobbing === true) {\n          args = args.slice(0, options.globStart).concat(expand(args.slice(options.globStart)));\n        }\n\n        try {\n          // parse options if options are provided\n          if (isObject(options.cmdOptions)) {\n            args[0] = parseOptions(args[0], options.cmdOptions);\n          }\n\n          retValue = fn.apply(this, args);\n        } catch (e) {\n          /* istanbul ignore else */\n          if (e.msg === 'earlyExit') {\n            retValue = e.retValue;\n          } else {\n            throw e; // this is probably a bug that should be thrown up the call stack\n          }\n        }\n      }\n    } catch (e) {\n      /* istanbul ignore next */\n      if (!state.error) {\n        // If state.error hasn't been set it's an error thrown by Node, not us - probably a bug...\n        e.name = 'ShellJSInternalError';\n        throw e;\n      }\n\n      if (config.fatal) throw e;\n    }\n\n    if (options.wrapOutput && (typeof retValue === 'string' || Array.isArray(retValue))) {\n      retValue = new ShellString(retValue, state.error, state.errorCode);\n    }\n\n    state.currentCmd = 'shell.js';\n    return retValue;\n  };\n} // wrap\n\n\nexports.wrap = wrap; // This returns all the input that is piped into the current command (or the\n// empty string, if this isn't on the right-hand side of a pipe\n\nfunction _readFromPipe() {\n  return state.pipedValue;\n}\n\nexports.readFromPipe = _readFromPipe;\nvar DEFAULT_WRAP_OPTIONS = {\n  allowGlobbing: true,\n  canReceivePipe: false,\n  cmdOptions: null,\n  globStart: 1,\n  pipeOnly: false,\n  wrapOutput: true,\n  unix: true\n}; // This is populated during plugin registration\n\nvar pipeMethods = []; // Register a new ShellJS command\n\nfunction _register(name, implementation, wrapOptions) {\n  wrapOptions = wrapOptions || {}; // Validate options\n\n  Object.keys(wrapOptions).forEach(function (option) {\n    if (!DEFAULT_WRAP_OPTIONS.hasOwnProperty(option)) {\n      throw new Error(\"Unknown option '\" + option + \"'\");\n    }\n\n    if (typeof wrapOptions[option] !== typeof DEFAULT_WRAP_OPTIONS[option]) {\n      throw new TypeError(\"Unsupported type '\" + typeof wrapOptions[option] + \"' for option '\" + option + \"'\");\n    }\n  }); // If an option isn't specified, use the default\n\n  wrapOptions = Object.assign({}, DEFAULT_WRAP_OPTIONS, wrapOptions);\n\n  if (shell[name]) {\n    throw new Error('Command `' + name + '` already exists');\n  }\n\n  if (wrapOptions.pipeOnly) {\n    wrapOptions.canReceivePipe = true;\n    shellMethods[name] = wrap(name, implementation, wrapOptions);\n  } else {\n    shell[name] = wrap(name, implementation, wrapOptions);\n  }\n\n  if (wrapOptions.canReceivePipe) {\n    pipeMethods.push(name);\n  }\n}\n\nexports.register = _register;","map":null,"metadata":{},"sourceType":"script"}