{"ast":null,"code":"var format = require('util').format;\n\nvar common = require('./common');\n\ncommon.register('echo', _echo, {\n  allowGlobbing: false\n}); //@\n//@ ### echo([options,] string [, string ...])\n//@\n//@ Available options:\n//@\n//@ + `-e`: interpret backslash escapes (default)\n//@ + `-n`: remove trailing newline from output\n//@\n//@ Examples:\n//@\n//@ ```javascript\n//@ echo('hello world');\n//@ var str = echo('hello world');\n//@ echo('-n', 'no newline at end');\n//@ ```\n//@\n//@ Prints `string` to stdout, and returns string with additional utility methods\n//@ like `.to()`.\n\nfunction _echo(opts) {\n  // allow strings starting with '-', see issue #20\n  var messages = [].slice.call(arguments, opts ? 0 : 1);\n  var options = {}; // If the first argument starts with '-', parse it as options string.\n  // If parseOptions throws, it wasn't an options string.\n\n  try {\n    options = common.parseOptions(messages[0], {\n      'e': 'escapes',\n      'n': 'no_newline'\n    }, {\n      silent: true\n    }); // Allow null to be echoed\n\n    if (messages[0]) {\n      messages.shift();\n    }\n  } catch (_) {\n    // Clear out error if an error occurred\n    common.state.error = null;\n  }\n\n  var output = format.apply(null, messages); // Add newline if -n is not passed.\n\n  if (!options.no_newline) {\n    output += '\\n';\n  }\n\n  process.stdout.write(output);\n  return output;\n}\n\nmodule.exports = _echo;","map":null,"metadata":{},"sourceType":"script"}